{"external_traits":{"PSP1155":"#[doc =\n\" Contract module which provides a basic implementation of multiple token types.\"]\n#[doc =\n\" A single deployed contract may include any combination of fungible tokens,\"]\n#[doc =\n\" non-fungible tokens or other configurations (e.g. semi-fungible tokens).\"]\npub trait PSP1155\n{\n    #[doc =\n    \" Returns the amount of tokens of token type `id` owned by `account`.\"]\n    #[ink(message)] #[ink(selector = 688445478u32)] fn\n    balance_of(& self, account : AccountId, id : Id) -> Balance ;\n    #[doc = \" Batched version of {balance_of}.\"] #[ink(message)]\n    #[ink(selector = 3186781366u32)] fn\n    balance_of_batch(& self, accounts_ids : Vec < (AccountId, Id) >) -> Vec <\n    Balance > ;\n    #[doc =\n    \" Grants or revokes permission to `operator` to transfer the caller\\'s tokens, according to `approved`\"]\n    #[doc = \"\"] #[doc = \" On success a `ApprovalForAll` event is emitted.\"]\n    #[doc = \"\"] #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc = \" Returns with `NotAllowed` error if it is self approve.\"]\n    #[ink(message)] #[ink(selector = 3004052505u32)] fn\n    set_approval_for_all(& mut self, operator : AccountId, approved : bool) ->\n    Result < (), PSP1155Error > ;\n    #[doc =\n    \" Returns true if `operator` is approved to transfer ``account``\\'s tokens.\"]\n    #[ink(message)] #[ink(selector = 2913857364u32)] fn\n    is_approved_for_all(& self, account : AccountId, operator : AccountId) ->\n    bool ;\n    #[doc =\n    \" Transfers `amount` tokens of token type `id` from `from` to `to`. Also some `data` can be passed.\"]\n    #[doc = \"\"] #[doc = \" On success a `TransferSingle` event is emitted.\"]\n    #[doc = \"\"] #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `TransferToZeroAddress` error if recipient is zero account.\"]\n    #[doc = \"\"]\n    #[doc = \" Returns `NotAllowed` error if transfer is not approved.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `InsufficientBalance` error if `from` doesn\\'t contain enough balance.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `SafeTransferCheckFailed` error if `to` doesn\\'t accept transfer.\"]\n    #[ink(message)] #[ink(selector = 2575733161u32)] fn\n    transfer_from(& mut self, from : AccountId, to : AccountId, id : Id,\n    amount : Balance, data : Vec < u8 >,) -> Result < (), PSP1155Error > ;\n    #[doc = \" Batched version of {safe_transfer_from}.\"] #[doc = \"\"]\n    #[doc = \" On success a `TransferBatch` event is emitted.\"] #[ink(message)]\n    #[ink(selector = 3847214567u32)] fn\n    batch_transfer_from(& mut self, from : AccountId, to : AccountId,\n    ids_amounts : Vec < (Id, Balance) >, data : Vec < u8 >,) -> Result < (),\n    PSP1155Error > ;\n}","Pausable":"#[doc =\n\" Contract trait, which allows children to implement an emergency stop\"]\n#[doc = \" mechanism that an authorized account can trigger.\"] pub trait\nPausable\n{\n    #[doc = \" Returns true if the contract is paused, and false otherwise.\"]\n    #[ink(message)] #[ink(selector = 3508784657u32)] fn paused(& self) -> bool\n    ;\n}","PSP1155Metadata":"pub trait PSP1155Metadata\n{\n    #[doc = \" Returns the uri for token type of id.\"] #[ink(message)]\n    #[ink(selector = 875598917u32)] fn uri(& self, _id : Id) -> Option <\n    String > ;\n}","PSP34Mintable":"pub trait PSP34Mintable\n{\n    #[doc = \" Mints a new token with `id`.\"] #[doc = \"\"]\n    #[doc = \" See [`PSP34::_mint`].\"] #[ink(message)]\n    #[ink(selector = 1816261356u32)] fn\n    mint(& mut self, account : AccountId, id : Id) -> Result < (), PSP34Error\n    > ;\n}","TimelockController":"#[doc =\n\" Contract module which acts as a time-locked controller. When set as the\"]\n#[doc =\n\" owner of an `Ownable` smart contract, it enforces a timelock on all\"]\n#[doc =\n\" `onlyOwner` maintenance operations. This gives time for users of the\"]\n#[doc =\n\" controlled contract to exit before a potentially dangerous maintenance\"]\n#[doc = \" operation is applied.\"] #[doc = \"\"]\n#[doc =\n\" By default, this contract is self-administered, meaning administration tasks\"]\n#[doc =\n\" have to go through the timelock process. The proposer (resp executor) role\"]\n#[doc =\n\" is in charge of proposing (resp executing) operations. A common use case is\"]\n#[doc =\n\" to position this `TimelockController` as the owner of a smart contract, with\"]\n#[doc = \" a multisig or a DAO as the sole proposer.\"] pub trait\nTimelockController : AccessControl\n{\n    #[doc =\n    \" Returns whether an id correspond to a registered operation. This\"]\n    #[doc = \" includes both Pending, Ready and Done operations.\"]\n    #[ink(message)] #[ink(selector = 833179961u32)] fn\n    is_operation(& self, id : OperationId) -> bool ;\n    #[doc = \" Returns whether an operation is pending or not.\"]\n    #[ink(message)] #[ink(selector = 2852774521u32)] fn\n    is_operation_pending(& self, id : OperationId) -> bool ;\n    #[doc = \" Returns whether an operation is ready or not.\"] #[ink(message)]\n    #[ink(selector = 3325091074u32)] fn\n    is_operation_ready(& self, id : OperationId) -> bool ;\n    #[doc = \" Returns whether an operation is done or not.\"] #[ink(message)]\n    #[ink(selector = 1049548971u32)] fn\n    is_operation_done(& self, id : OperationId) -> bool ;\n    #[doc =\n    \" Returns the timestamp at with an operation becomes ready (0 for\"]\n    #[doc = \" unset operations, 1 for done operations).\"] #[ink(message)]\n    #[ink(selector = 3988478265u32)] fn\n    get_timestamp(& self, id : OperationId) -> Timestamp ;\n    #[doc = \" Returns the minimum delay for an operation to become valid.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" This value can be changed by executing an operation that calls `update_delay`.\"]\n    #[ink(message)] #[ink(selector = 3852146035u32)] fn get_min_delay(& self)\n    -> Timestamp ;\n    #[doc = \" Returns the identifier of an operation containing a single\"]\n    #[doc = \" transaction.\"] #[ink(message)] #[ink(selector = 3432286849u32)]\n    fn\n    hash_operation(& self, transaction : Transaction, predecessor : Option <\n    OperationId >, salt : [u8 ; 32]) -> Hash ;\n    #[doc = \" Returns the identifier of an operation containing a batch of\"]\n    #[doc = \" transactions.\"] #[ink(message)] #[ink(selector = 4030034614u32)]\n    fn\n    hash_operation_batch(& self, transactions : Vec < Transaction >,\n    predecessor : Option < OperationId >, salt : [u8 ; 32],) -> Hash ;\n    #[doc = \" Schedule an operation containing a single transaction.\"]\n    #[doc = \"\"] #[doc = \" Emits a `CallScheduled` event.\"] #[doc = \"\"]\n    #[doc = \" Node: The caller must have the \\'PROPOSER_ROLE\\' role.\"]\n    #[ink(message)] #[ink(selector = 2411105774u32)] fn\n    schedule(& mut self, transaction : Transaction, predecessor : Option <\n    OperationId >, salt : [u8 ; 32], delay : Timestamp,) -> Result < (),\n    TimelockControllerError > ;\n    #[doc = \" Schedule an operation containing a batch of transactions.\"]\n    #[doc = \"\"]\n    #[doc = \" Emits one `CallScheduled` event per transaction in the batch.\"]\n    #[doc = \"\"]\n    #[doc = \" Node: The caller must have the \\'PROPOSER_ROLE\\' role.\"]\n    #[ink(message)] #[ink(selector = 3404191332u32)] fn\n    schedule_batch(& mut self, transactions : Vec < Transaction >, predecessor\n    : Option < OperationId >, salt : [u8 ; 32], delay : Timestamp,) -> Result\n    < (), TimelockControllerError > ; #[doc = \" Cancel an operation.\"]\n    #[doc = \"\"] #[doc = \" On success a `Cancelled` event is emitted.\"]\n    #[doc = \"\"]\n    #[doc = \" Note: the caller must have the \\'PROPOSER_ROLE\\' role.\"]\n    #[ink(message)] #[ink(selector = 3457228928u32)] fn\n    cancel(& mut self, id : OperationId) -> Result < (),\n    TimelockControllerError > ;\n    #[doc = \" Execute an (ready) operation containing a single transaction.\"]\n    #[doc = \"\"] #[doc = \" Emits a `CallExecuted` event.\"] #[doc = \"\"]\n    #[doc = \" Note: The caller must have the \\'EXECUTOR_ROLE\\' role.\"]\n    #[ink(message, payable)] #[ink(selector = 767509891u32)] fn\n    execute(& mut self, transaction : Transaction, predecessor : Option <\n    OperationId >, salt : [u8 ; 32],) -> Result < (), TimelockControllerError\n    > ;\n    #[doc =\n    \" Execute an (ready) operation containing a batch of transactions.\"]\n    #[doc = \"\"]\n    #[doc = \" Emits one `CallExecuted` event per transaction in the batch.\"]\n    #[doc = \"\"]\n    #[doc = \" Note: The caller must have the \\'EXECUTOR_ROLE\\' role.\"]\n    #[ink(message, payable)] #[ink(selector = 3704973290u32)] fn\n    execute_batch(& mut self, transactions : Vec < Transaction >, predecessor\n    : Option < OperationId >, salt : [u8 ; 32],) -> Result < (),\n    TimelockControllerError > ;\n    #[doc = \" Changes the minimum timelock duration for future operations.\"]\n    #[doc = \"\"] #[doc = \" Emits a `MinDelayChange` event.\"] #[doc = \"\"]\n    #[doc = \" Note: The caller must has `TIMELOCK_ADMIN_ROLE` itself.\"]\n    #[doc = \" This can only be achieved by scheduling and later executing\"]\n    #[doc =\n    \" an operation where the timelock is the target and the data is the\"]\n    #[doc = \" ABI-encoded call to this function.\"] #[ink(message)]\n    #[ink(selector = 884960752u32)] fn\n    update_delay(& mut self, new_delay : Timestamp) -> Result < (),\n    TimelockControllerError > ;\n}","PSP1155Mintable":"pub trait PSP1155Mintable\n{\n    #[doc = \" Mints `amount` tokens of token type `id` to `to`\"] #[doc = \"\"]\n    #[doc = \" See [`PSP1155::_mint_to`].\"] #[ink(message)]\n    #[ink(selector = 2871344384u32)] fn\n    mint(& mut self, to : AccountId, ids_amounts : Vec < (Id, Balance) >) ->\n    Result < (), PSP1155Error > ;\n}","PSP34Receiver":"#[doc =\n\" PSP34Receiver is a trait for any contract that wants to support safe transfers from a PSP34\"]\n#[doc =\n\" token smart contract to avoid unexpected tokens in the balance of contract.\"]\n#[doc =\n\" This method is called before a transfer to ensure the recipient of the tokens acknowledges the receipt.\"]\npub trait PSP34Receiver\n{\n    #[doc =\n    \" Ensures that the smart contract allows reception of PSP34 token(s).\"]\n    #[doc =\n    \" Returns `Ok(())` if the contract allows the reception of the token(s) and Error `TransferRejected(String))` otherwise.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" This method will get called on every transfer to check whether the recipient in `transfer`\"]\n    #[doc =\n    \" or `transfer_from` is a contract, and if it is, does it accept tokens.\"]\n    #[doc = \" This is done to prevent contracts from locking tokens forever.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `PSP34ReceiverError` if the contract does not accept the tokens.\"]\n    #[ink(message)] #[ink(selector = 3145594752u32)] fn\n    before_received(& mut self, operator : AccountId, from : AccountId, id :\n    Id, data : Vec < u8 >,) -> Result < (), PSP34ReceiverError > ;\n}","PSP22TokenTimelock":"pub trait PSP22TokenTimelock\n{\n    #[doc = \" Returns the token address\"] #[ink(message)]\n    #[ink(selector = 2148413725u32)] fn token(& self) -> AccountId ;\n    #[doc = \" Returns the beneficiary of the tokens\"] #[ink(message)]\n    #[ink(selector = 2974500365u32)] fn beneficiary(& self) -> AccountId ;\n    #[doc = \" Returns the timestamp when the tokens are released\"]\n    #[ink(message)] #[ink(selector = 335395828u32)] fn release_time(& self) ->\n    Timestamp ;\n    #[doc = \" Transfers the tokens held by timelock to the beneficairy\"]\n    #[ink(message)] #[ink(selector = 3380617463u32)] fn release(& mut self) ->\n    Result < (), PSP22TokenTimelockError > ;\n}","PSP22Receiver":"#[doc =\n\" PSP22Receiver is a trait for any contract that wants to support safe transfers from a PSP22\"]\n#[doc =\n\" token smart contract to avoid unexpected tokens in the balance of contract.\"]\n#[doc =\n\" This method is called before a transfer to ensure the recipient of the tokens acknowledges the receipt.\"]\npub trait PSP22Receiver\n{\n    #[doc =\n    \" Ensures that the smart contract allows reception of PSP22 token(s).\"]\n    #[doc =\n    \" Returns `Ok(())` if the contract allows the reception of the token(s) and Error `TransferRejected(String))` otherwise.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" This method will get called on every transfer to check whether the recipient in `transfer` or\"]\n    #[doc =\n    \" `transfer_from` is a contract, and if it is, does it accept tokens.\"]\n    #[doc = \" This is done to prevent contracts from locking tokens forever.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `PSP22ReceiverError` if the contract does not accept the tokens.\"]\n    #[ink(message)] #[ink(selector = 4255576489u32)] fn\n    before_received(& mut self, operator : AccountId, from : AccountId, value\n    : Balance, data : Vec < u8 >,) -> Result < (), PSP22ReceiverError > ;\n}","PSP34Burnable":"pub trait PSP34Burnable\n{\n    #[doc = \" Destroys token with id equal to `id` from `account`\"]\n    #[doc = \"\"]\n    #[doc = \" Caller must be approved to transfer tokens from `account`\"]\n    #[doc = \" or to transfer token with `id`\"] #[ink(message)]\n    #[ink(selector = 1674151802u32)] fn\n    burn(& mut self, account : AccountId, id : Id) -> Result < (), PSP34Error\n    > ;\n}","PaymentSplitter":"#[doc =\n\" This contract allows splitting native token payments among a group of accounts. The sender does not need to be aware\"]\n#[doc =\n\" that the native token will be split in this way, since it is handled transparently by the contract.\"]\n#[doc = \"\"]\n#[doc =\n\" The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\"]\n#[doc =\n\" account to a number of shares. Of all the native tokens that this contract receives, each account will then be able to claim\"]\n#[doc =\n\" an amount proportional to the percentage of total shares they were assigned.\"]\n#[doc = \"\"]\n#[doc =\n\" `PaymentSplitter` follows a pull payment model. This means that payments are not automatically forwarded to the\"]\n#[doc =\n\" accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the `release`\"]\n#[doc = \" function.\"] pub trait PaymentSplitter\n{\n    #[doc = \" Getter for the total shares held by payees.\"] #[ink(message)]\n    #[ink(selector = 2040411684u32)] fn total_shares(& self) -> Balance ;\n    #[doc = \" Getter for the total amount of native token already released.\"]\n    #[ink(message)] #[ink(selector = 696265406u32)] fn total_released(& self)\n    -> Balance ;\n    #[doc = \" Getter for the amount of shares held by an account.\"]\n    #[ink(message)] #[ink(selector = 2873236965u32)] fn\n    shares(& self, account : AccountId) -> Balance ;\n    #[doc =\n    \" Getter for the amount of native token already released to a payee.\"]\n    #[ink(message)] #[ink(selector = 2642618273u32)] fn\n    released(& self, account : AccountId) -> Balance ;\n    #[doc = \" Getter for the address of the payee number `index`.\"]\n    #[ink(message)] #[ink(selector = 1828221412u32)] fn\n    payee(& self, index : u32) -> AccountId ;\n    #[doc =\n    \" The native token received will be logged with `PaymentReceived` events.\"]\n    #[doc =\n    \" Note that these events are not fully reliable: a contract can receive a native token\"]\n    #[doc =\n    \" without triggering this function. This only affects the reliability of the events\"]\n    #[doc = \" and not the actual splitting of the native token.\"] #[doc = \"\"]\n    #[doc = \" On success a `PayeeAdded` event is emitted.\"]\n    #[ink(message, payable)] #[ink(selector = 686692301u32)] fn\n    receive(& mut self) ;\n    #[doc =\n    \" Triggers a transfer to `account` of the amount of native token they are owed, according to their percentage of the\"]\n    #[doc = \" total shares and their previous withdrawals.\"] #[doc = \"\"]\n    #[doc = \" On success a `PaymentReleased` event is emitted.\"]\n    #[ink(message)] #[ink(selector = 949048064u32)] fn\n    release(& mut self, account : AccountId) -> Result < (),\n    PaymentSplitterError > ;\n}","Ownable":"#[doc =\n\" Contract module which provides a basic access control mechanism, where\"]\n#[doc =\n\" there is an account (an owner) that can be granted exclusive access to\"]\n#[doc = \" specific functions.\"] pub trait Ownable\n{\n    #[doc = \" Returns the address of the current owner.\"] #[ink(message)]\n    #[ink(selector = 1336163468u32)] fn owner(& self) -> AccountId ;\n    #[doc =\n    \" Leaves the contract without owner. It will not be possible to call\"]\n    #[doc =\n    \" owner\\'s functions anymore. Can only be called by the current owner.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" NOTE: Renouncing ownership will leave the contract without an owner,\"]\n    #[doc =\n    \" thereby removing any functionality that is only available to the owner.\"]\n    #[doc = \"\"]\n    #[doc = \" On success a `OwnershipTransferred` event is emitted.\"]\n    #[doc = \"\"] #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc = \" Panics with `CallerIsNotOwner` error if caller is not owner\"]\n    #[ink(message)] #[ink(selector = 1579321171u32)] fn\n    renounce_ownership(& mut self) -> Result < (), OwnableError > ;\n    #[doc = \" Transfers ownership of the contract to a `new_owner`.\"]\n    #[doc = \" Can only be called by the current owner.\"] #[doc = \"\"]\n    #[doc = \" On success a `OwnershipTransferred` event is emitted.\"]\n    #[doc = \"\"] #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc = \" Panics with `CallerIsNotOwner` error if caller is not owner.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Panics with `NewOwnerIsZero` error if new owner\\'s address is zero.\"]\n    #[ink(message)] #[ink(selector = 301219581u32)] fn\n    transfer_ownership(& mut self, new_owner : AccountId) -> Result < (),\n    OwnableError > ;\n}","AccessControl":"#[doc =\n\" Contract module that allows children to implement role-based access\"]\n#[doc =\n\" control mechanisms. This is a lightweight version that doesn\\'t allow enumerating role\"]\n#[doc =\n\" members except through off-chain means by accessing the contract event logs.\"]\n#[doc = \"\"]\n#[doc =\n\" Roles can be granted and revoked dynamically via the `grant_role` and\"]\n#[doc =\n\" `revoke_role`. functions. Each role has an associated admin role, and only\"]\n#[doc =\n\" accounts that have a role\\'s admin role can call `grant_role` and `revoke_role`.\"]\npub trait AccessControl\n{\n    #[doc = \" Returns `true` if `account` has been granted `role`.\"]\n    #[ink(message)] #[ink(selector = 3252268056u32)] fn\n    has_role(& self, role : RoleType, address : AccountId) -> bool ;\n    #[doc =\n    \" Returns the admin role that controls `role`. See `grant_role` and `revoke_role`.\"]\n    #[ink(message)] #[ink(selector = 2212117426u32)] fn\n    get_role_admin(& self, role : RoleType) -> RoleType ;\n    #[doc = \" Grants `role` to `account`.\"] #[doc = \"\"]\n    #[doc = \" On success a `RoleGranted` event is emitted.\"] #[doc = \"\"]\n    #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc =\n    \" Returns with `MissingRole` error if caller can\\'t grant the role.\"]\n    #[doc = \" Returns with `RoleRedundant` error `account` has `role`.\"]\n    #[ink(message)] #[ink(selector = 1254122237u32)] fn\n    grant_role(& mut self, role : RoleType, account : AccountId) -> Result <\n    (), AccessControlError > ; #[doc = \" Revokes `role` from `account`.\"]\n    #[doc = \"\"] #[doc = \" On success a `RoleRevoked` event is emitted.\"]\n    #[doc = \"\"] #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc =\n    \" Returns with `MissingRole` error if caller can\\'t grant the `role` or if `account` doesn\\'t have `role`.\"]\n    #[ink(message)] #[ink(selector = 1850673553u32)] fn\n    revoke_role(& mut self, role : RoleType, account : AccountId) -> Result <\n    (), AccessControlError > ;\n    #[doc = \" Revokes `role` from the calling account.\"]\n    #[doc =\n    \" Roles are often managed via `grant_role` and `revoke_role`: this function\\'s\"]\n    #[doc =\n    \" purpose is to provide a mechanism for accounts to lose their privileges\"]\n    #[doc =\n    \" if they are compromised (such as when a trusted device is misplaced).\"]\n    #[doc = \"\"] #[doc = \" On success a `RoleRevoked` event is emitted.\"]\n    #[doc = \"\"] #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc = \" Returns with `InvalidCaller` error if caller is not `account`.\"]\n    #[doc =\n    \" Returns with `MissingRole` error if `account` doesn\\'t have `role`.\"]\n    #[ink(message)] #[ink(selector = 3941672074u32)] fn\n    renounce_role(& mut self, role : RoleType, account : AccountId) -> Result\n    < (), AccessControlError > ;\n}","FlashLender":"#[doc = \" TODO remove eip link\"]\n#[doc =\n\" Flash Lender implementation as proposed in https://eips.ethereum.org/EIPS/eip-3156)\"]\npub trait FlashLender\n{\n    #[doc =\n    \" Call this function in `max_flashloan` function in `impl` block of FlashLender\"]\n    #[doc = \" Maximum amount of `token` available to mint\"]\n    #[doc = \" Bounded by the max value of Balance (u128)\"] #[ink(message)]\n    #[ink(selector = 2581442024u32)] fn\n    max_flashloan(& mut self, token : AccountId) -> Balance ;\n    #[doc =\n    \" Call this function in `flash_fee` function in `impl` block of FlashLender\"]\n    #[doc = \" Fee for borrowing `amount` of the `token`\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `WrongTokenAddress` error if the `token` account id is not this token\"]\n    #[ink(message)] #[ink(selector = 3499821135u32)] fn\n    flash_fee(& self, token : AccountId, amount : Balance) -> Result <\n    Balance, FlashLenderError > ;\n    #[doc =\n    \" Call this function in `flashloan` function in `impl` block of FlashLender\"]\n    #[doc =\n    \" Mints `amount` of `token` to `receiver_account` and performs the flashloan\"]\n    #[doc = \" `amount` is then burned along with the fee for the flashloan\"]\n    #[doc = \" `receiver_account` must implement `FlashBorrower`\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `AllowanceDoesNotAllowRefund` error if the contract does not have\"]\n    #[doc =\n    \" enough allowance to transfer borrowed amount and fees from `receiver_account`\"]\n    #[ink(message)] #[ink(selector = 1733893728u32)] fn\n    flashloan(& mut self, receiver_account : AccountId, token : AccountId,\n    amount : Balance, data : Vec < u8 >,) -> Result < (), FlashLenderError > ;\n}","PSP22Mintable":"pub trait PSP22Mintable\n{\n    #[doc = \" Minting `amount` tokens to the account.\"] #[doc = \"\"]\n    #[doc = \" See [`PSP22::_mint`].\"] #[ink(message)]\n    #[ink(selector = 4231820756u32)] fn\n    mint(& mut self, account : AccountId, amount : Balance) -> Result < (),\n    PSP22Error > ;\n}","PSP22Wrapper":"pub trait PSP22Wrapper : PSP22\n{\n    #[doc =\n    \" Allow a user to deposit `amount` of underlying tokens and mint `amount` of the wrapped tokens to `account`\"]\n    #[ink(message)] #[ink(selector = 1289939587u32)] fn\n    deposit_for(& mut self, account : AccountId, amount : Balance) -> Result <\n    (), PSP22Error > ;\n    #[doc =\n    \" Allow a user to burn `amount` of wrapped tokens and withdraw the corresponding number of underlying tokens to `account`\"]\n    #[ink(message)] #[ink(selector = 3135331750u32)] fn\n    withdraw_to(& mut self, account : AccountId, amount : Balance) -> Result <\n    (), PSP22Error > ;\n}","PSP34":"#[doc =\n\" Contract module which provides a basic implementation of non fungible token.\"]\npub trait PSP34\n{\n    #[doc = \" Returns the collection `Id` of the NFT token.\"] #[doc = \"\"]\n    #[doc =\n    \" This can represents the relationship between tokens/contracts/pallets.\"]\n    #[ink(message)] #[ink(selector = 4288838239u32)] fn collection_id(& self)\n    -> Id ; #[doc = \" Returns the balance of the owner.\"] #[doc = \"\"]\n    #[doc = \" This represents the amount of unique tokens the owner has.\"]\n    #[ink(message)] #[ink(selector = 3454526815u32)] fn\n    balance_of(& self, owner : AccountId) -> u32 ;\n    #[doc = \" Returns the owner of the token if any.\"] #[ink(message)]\n    #[ink(selector = 292053581u32)] fn owner_of(& self, id : Id) -> Option <\n    AccountId > ;\n    #[doc =\n    \" Returns `true` if the operator is approved by the owner to withdraw `id` token.\"]\n    #[doc =\n    \" If `id` is `None`, returns `true` if the operator is approved to withdraw all owner\\'s tokens.\"]\n    #[ink(message)] #[ink(selector = 1200682330u32)] fn\n    allowance(& self, owner : AccountId, operator : AccountId, id : Option <\n    Id >) -> bool ;\n    #[doc =\n    \" Approves `operator` to withdraw the `id` token from the caller\\'s account.\"]\n    #[doc =\n    \" If `id` is `None` approves or disapproves the operator for all tokens of the caller.\"]\n    #[doc = \"\"] #[doc = \" On success a `Approval` event is emitted.\"]\n    #[doc = \"\"] #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc = \" Returns `SelfApprove` error if it is self approve.\"] #[doc = \"\"]\n    #[doc = \" Returns `NotApproved` error if caller is not owner of `id`.\"]\n    #[ink(message)] #[ink(selector = 422750384u32)] fn\n    approve(& mut self, operator : AccountId, id : Option < Id >, approved :\n    bool) -> Result < (), PSP34Error > ;\n    #[doc = \" Transfer approved or owned token from caller.\"] #[doc = \"\"]\n    #[doc = \" On success a `Transfer` event is emitted.\"] #[doc = \"\"]\n    #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc = \" Returns `TokenNotExists` error if `id` does not exist.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `NotApproved` error if `from` doesn\\'t have allowance for transferring.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `SafeTransferCheckFailed` error if `to` doesn\\'t accept transfer.\"]\n    #[ink(message)] #[ink(selector = 824759835u32)] fn\n    transfer(& mut self, to : AccountId, id : Id, data : Vec < u8 >) -> Result\n    < (), PSP34Error > ; #[doc = \" Returns current NFT total supply.\"]\n    #[ink(message)] #[ink(selector = 1652823038u32)] fn total_supply(& self)\n    -> Balance ;\n}","FlashBorrower":"#[doc = \" TODO remove eip link\"]\n#[doc =\n\" Flash Borrower implementation as proposed in https://eips.ethereum.org/EIPS/eip-3156)\"]\npub trait FlashBorrower\n{\n    #[ink(message)] #[ink(selector = 1548055508u32)] fn\n    on_flashloan(& mut self, initiator : AccountId, token : AccountId, amount\n    : Balance, fee : Balance, data : Vec < u8 >,) -> Result < (),\n    FlashBorrowerError > ;\n}","PSP34Metadata":"pub trait PSP34Metadata\n{\n    #[doc = \" Returns the attribute of `id` for the given `key`.\"] #[doc = \"\"]\n    #[doc =\n    \" If `id` is a collection id of the token, it returns attributes for collection.\"]\n    #[ink(message)] #[ink(selector = 4053616849u32)] fn\n    get_attribute(& self, id : Id, key : Vec < u8 >) -> Option < Vec < u8 > >\n    ;\n}","PSP1155Burnable":"pub trait PSP1155Burnable\n{\n    #[doc = \" Destroys `amount` tokens of token type `id` from `from`\"]\n    #[doc = \"\"] #[doc = \" See [`PSP1155::_burn_from`].\"] #[ink(message)]\n    #[ink(selector = 2272861627u32)] fn\n    burn(& mut self, from : AccountId, ids_amounts : Vec < (Id, Balance) >) ->\n    Result < (), PSP1155Error > ;\n}","Proxy":"pub trait Proxy : Ownable\n{\n    #[ink(message)] #[ink(selector = 4026764969u32)] fn\n    get_delegate_code(& self) -> Hash ; #[ink(message)]\n    #[ink(selector = 2941781364u32)] fn\n    change_delegate_code(& mut self, new_code_hash : Hash) -> Result < (),\n    OwnableError > ;\n}","PSP22Metadata":"#[doc = \" Trait that contains metadata\"] pub trait PSP22Metadata\n{\n    #[doc = \" Returns the token name.\"] #[ink(message)]\n    #[ink(selector = 1025907668u32)] fn token_name(& self) -> Option < String\n    > ; #[doc = \" Returns the token symbol.\"] #[ink(message)]\n    #[ink(selector = 874535909u32)] fn token_symbol(& self) -> Option < String\n    > ; #[doc = \" Returns the token decimals.\"] #[ink(message)]\n    #[ink(selector = 1920055170u32)] fn token_decimals(& self) -> u8 ;\n}","PSP22":"#[doc = \" Trait implemented by all PSP-20 respecting smart traits.\"] pub trait\nPSP22\n{\n    #[doc = \" Returns the total token supply.\"] #[ink(message)]\n    #[ink(selector = 372111554u32)] fn total_supply(& self) -> Balance ;\n    #[doc = \" Returns the account Balance for the specified `owner`.\"]\n    #[doc = \"\"] #[doc = \" Returns `0` if the account is non-existent.\"]\n    #[ink(message)] #[ink(selector = 1701328943u32)] fn\n    balance_of(& self, owner : AccountId) -> Balance ;\n    #[doc =\n    \" Returns the amount which `spender` is still allowed to withdraw from `owner`.\"]\n    #[doc = \"\"] #[doc = \" Returns `0` if no allowance has been set `0`.\"]\n    #[ink(message)] #[ink(selector = 1296554273u32)] fn\n    allowance(& self, owner : AccountId, spender : AccountId) -> Balance ;\n    #[doc =\n    \" Transfers `value` amount of tokens from the caller\\'s account to account `to`\"]\n    #[doc = \" with additional `data` in unspecified format.\"] #[doc = \"\"]\n    #[doc = \" On success a `Transfer` event is emitted.\"] #[doc = \"\"]\n    #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `InsufficientBalance` error if there are not enough tokens on\"]\n    #[doc = \" the caller\\'s account Balance.\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroSenderAddress` error if sender\\'s address is zero.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroRecipientAddress` error if recipient\\'s address is zero.\"]\n    #[ink(message)] #[ink(selector = 3676371445u32)] fn\n    transfer(& mut self, to : AccountId, value : Balance, data : Vec < u8 >)\n    -> Result < (), PSP22Error > ;\n    #[doc =\n    \" Transfers `value` tokens on the behalf of `from` to the account `to`\"]\n    #[doc = \" with additional `data` in unspecified format.\"] #[doc = \"\"]\n    #[doc =\n    \" This can be used to allow a contract to transfer tokens on ones behalf and/or\"]\n    #[doc = \" to charge fees in sub-currencies, for example.\"] #[doc = \"\"]\n    #[doc = \" On success a `Transfer` and `Approval` events are emitted.\"]\n    #[doc = \"\"] #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `InsufficientAllowance` error if there are not enough tokens allowed\"]\n    #[doc = \" for the caller to withdraw from `from`.\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `InsufficientBalance` error if there are not enough tokens on\"]\n    #[doc = \" the the account Balance of `from`.\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroSenderAddress` error if sender\\'s address is zero.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroRecipientAddress` error if recipient\\'s address is zero.\"]\n    #[ink(message)] #[ink(selector = 1421068142u32)] fn\n    transfer_from(& mut self, from : AccountId, to : AccountId, value :\n    Balance, data : Vec < u8 >,) -> Result < (), PSP22Error > ;\n    #[doc =\n    \" Allows `spender` to withdraw from the caller\\'s account multiple times, up to\"]\n    #[doc = \" the `value` amount.\"] #[doc = \"\"]\n    #[doc =\n    \" If this function is called again it overwrites the current allowance with `value`.\"]\n    #[doc = \"\"] #[doc = \" An `Approval` event is emitted.\"] #[doc = \"\"]\n    #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroSenderAddress` error if sender\\'s address is zero.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroRecipientAddress` error if recipient\\'s address is zero.\"]\n    #[ink(message)] #[ink(selector = 2987334589u32)] fn\n    approve(& mut self, spender : AccountId, value : Balance) -> Result < (),\n    PSP22Error > ;\n    #[doc =\n    \" Atomically increases the allowance granted to `spender` by the caller.\"]\n    #[doc = \"\"] #[doc = \" An `Approval` event is emitted.\"] #[doc = \"\"]\n    #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroSenderAddress` error if sender\\'s address is zero.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroRecipientAddress` error if recipient\\'s address is zero.\"]\n    #[ink(message)] #[ink(selector = 2530653562u32)] fn\n    increase_allowance(& mut self, spender : AccountId, delta_value : Balance)\n    -> Result < (), PSP22Error > ;\n    #[doc =\n    \" Atomically decreases the allowance granted to `spender` by the caller.\"]\n    #[doc = \"\"] #[doc = \" An `Approval` event is emitted.\"] #[doc = \"\"]\n    #[doc = \" # Errors\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `InsufficientAllowance` error if there are not enough tokens allowed\"]\n    #[doc = \" by owner for `spender`.\"] #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroSenderAddress` error if sender\\'s address is zero.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `ZeroRecipientAddress` error if recipient\\'s address is zero.\"]\n    #[ink(message)] #[ink(selector = 4274739157u32)] fn\n    decrease_allowance(& mut self, spender : AccountId, delta_value : Balance)\n    -> Result < (), PSP22Error > ;\n}","PSP22Burnable":"pub trait PSP22Burnable\n{\n    #[doc =\n    \" Destroys `amount` tokens from `account`, deducting from the caller\\'s\"]\n    #[doc = \" allowance.\"] #[doc = \"\"] #[doc = \" See [`PSP22::_burn_from`].\"]\n    #[ink(message)] #[ink(selector = 2057151760u32)] fn\n    burn(& mut self, account : AccountId, amount : Balance) -> Result < (),\n    PSP22Error > ;\n}","PSP1155Receiver":"#[doc =\n\" PSP1155Receiver is a trait for any contract that wants to support safe transfers from a PSP1155\"]\n#[doc =\n\" multi token smart contract to avoid unexpected tokens in the balance of contract.\"]\n#[doc =\n\" This method is called before a transfer to ensure the recipient of the tokens acknowledges the receipt.\"]\npub trait PSP1155Receiver\n{\n    #[doc =\n    \" Ensures that the smart contract allows reception of PSP1155 token(s).\"]\n    #[doc =\n    \" Returns `Ok(())` if the contract allows the reception of the token(s) and Error `TransferRejected(String))` otherwise.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" This method will get called on every transfer to check whether the recipient in `transfer_from`\"]\n    #[doc =\n    \" or `batch_transfer_from` is a contract, and if it is, does it accept tokens.\"]\n    #[doc = \" This is done to prevent contracts from locking tokens forever.\"]\n    #[doc = \"\"]\n    #[doc =\n    \" Returns `PSP1155ReceiverError` if the contract does not accept the tokens.\"]\n    #[ink(message)] #[ink(selector = 1466150728u32)] fn\n    before_received(& mut self, operator : AccountId, from : AccountId,\n    ids_to_amounts : Vec < (Id, Balance) >, data : Vec < u8 >,) -> Result <\n    (), PSP1155ReceiverError > ;\n}"}}